Fixes CVE-2018-11694: https://nvd.nist.gov/vuln/detail/CVE-2018-11694,
which is a vulnerability in libsass module version 3.5.5
[Even though NVD lists CPE upto including 3.5.4, 3.5.5 also contains the
vulnerable code.]

This patch adpats fixes in libsass sources for the mentioned CVE:
Patch: https://github.com/sass/libsass/pull/2760
Patch: https://github.com/sass/libsass/pull/2762
Issue: https://github.com/sass/libsass/issues/2663

From 2214ae16d9d9ec4c102c56a53ff5fb8d25217dd4 Mon Sep 17 00:00:00 2001
From: <redacted>
Date: Fri, 4 Aug 2023 15:04:06 +0530
Subject: [PATCH] Disallow parent selectors in selector-append.
                 Fix crash in selector-append('.x~~', 'a')

---
 .../node-sass/src/libsass/src/functions.cpp   | 26 +++++++++++--------
 .../node-sass/src/libsass/src/parser.cpp      | 14 +++++-----
 .../node-sass/src/libsass/src/parser.hpp      | 13 +++++-----
 3 files changed, 29 insertions(+), 24 deletions(-)

diff --git a/node_modules/node-sass/src/libsass/src/functions.cpp b/node_modules/node-sass/src/libsass/src/functions.cpp
index c9999fc3..4227d4de 100644
--- a/node_modules/node-sass/src/libsass/src/functions.cpp
+++ b/node_modules/node-sass/src/libsass/src/functions.cpp
@@ -240,13 +240,13 @@ namespace Sass {
         std::stringstream msg;
         msg << argname << ": null is not a valid selector: it must be a string,\n";
         msg << "a list of strings, or a list of lists of strings for `" << function_name(sig) << "'";
-        error(msg.str(), pstate, traces);
+        error(msg.str(), exp->pstate(), traces);
       }
       if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {
         str->quote_mark(0);
       }
       std::string exp_src = exp->to_string(ctx.c_options);
-      return Parser::parse_selector(exp_src.c_str(), ctx, traces);
+      return Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
     }
 
     template <>
@@ -255,13 +255,13 @@ namespace Sass {
       if (exp->concrete_type() == Expression::NULL_VAL) {
         std::stringstream msg;
         msg << argname << ": null is not a string for `" << function_name(sig) << "'";
-        error(msg.str(), pstate, traces);
+        error(msg.str(), exp->pstate(), traces);
       }
       if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {
         str->quote_mark(0);
       }
       std::string exp_src = exp->to_string(ctx.c_options);
-      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces);
+      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
       if (sel_list->length() == 0) return NULL;
       Complex_Selector_Obj first = sel_list->first();
       if (!first->tail()) return first->head();
@@ -1970,7 +1970,7 @@ namespace Sass {
           str->quote_mark(0);
         }
         std::string exp_src = exp->to_string(ctx.c_options);
-        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces);
+        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
         parsedSelectors.push_back(sel);
       }
 
@@ -2023,7 +2023,9 @@ namespace Sass {
           str->quote_mark(0);
         }
         std::string exp_src = exp->to_string();
-        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces);
+        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces,
+                                                       exp->pstate(), pstate.src,
+                                                       /*allow_parent=*/false);
         parsedSelectors.push_back(sel);
       }
 
@@ -2077,11 +2079,13 @@ namespace Sass {
 
             // TODO: Add check for namespace stuff
 
-            // append any selectors in childSeq's head
-            parentSeqClone->innermost()->head()->concat(base->head());
-
-            // Set parentSeqClone new tail
-            parentSeqClone->innermost()->tail( base->tail() );
+            Complex_Selector_Ptr lastComponent = parentSeqClone->mutable_last();
+            if (lastComponent->head() == nullptr) {
+              std::string msg = "Parent \"" + parentSeqClone->to_string() + "\" is incompatible with \"" + base->to_string() + "\"";
+              error(msg, pstate, traces);
+            }
+            lastComponent->head()->concat(base->head());
+            lastComponent->tail(base->tail());
 
             newElements.push_back(parentSeqClone);
           }
diff --git a/node_modules/node-sass/src/libsass/src/parser.cpp b/node_modules/node-sass/src/libsass/src/parser.cpp
index 28fe0224..8d916269 100644
--- a/node_modules/node-sass/src/libsass/src/parser.cpp
+++ b/node_modules/node-sass/src/libsass/src/parser.cpp
@@ -30,11 +30,11 @@ namespace Sass {
   using namespace Constants;
   using namespace Prelexer;
 
-  Parser Parser::from_c_str(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source)
+  Parser Parser::from_c_str(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source, bool allow_parent)
   {
     pstate.offset.column = 0;
     pstate.offset.line = 0;
-    Parser p(ctx, pstate, traces);
+    Parser p(ctx, pstate, traces, allow_parent);
     p.source   = source ? source : beg;
     p.position = beg ? beg : p.source;
     p.end      = p.position + strlen(p.position);
@@ -44,11 +44,11 @@ namespace Sass {
     return p;
   }
 
-  Parser Parser::from_c_str(const char* beg, const char* end, Context& ctx, Backtraces traces, ParserState pstate, const char* source)
+  Parser Parser::from_c_str(const char* beg, const char* end, Context& ctx, Backtraces traces, ParserState pstate, const char* source, bool allow_parent)
   {
     pstate.offset.column = 0;
     pstate.offset.line = 0;
-    Parser p(ctx, pstate, traces);
+    Parser p(ctx, pstate, traces, allow_parent);
     p.source   = source ? source : beg;
     p.position = beg ? beg : p.source;
     p.end      = end ? end : p.position + strlen(p.position);
@@ -66,10 +66,9 @@ namespace Sass {
       pstate.offset.line = 0;
     }
 
-  Selector_List_Obj Parser::parse_selector(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source)
+  Selector_List_Obj Parser::parse_selector(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source, bool allow_parent)
   {
-    Parser p = Parser::from_c_str(beg, ctx, traces, pstate, source);
-    // ToDo: ruby sass errors on parent references
+    Parser p = Parser::from_c_str(beg, ctx, traces, pstate, source, allow_parent);
     // ToDo: remap the source-map entries somehow
     return p.parse_selector_list(false);
   }
@@ -818,6 +817,7 @@ namespace Sass {
       // parse parent selector
       else if (lex< exactly<'&'> >(false))
       {
+        if (!allow_parent) error("Parent selectors aren't allowed here.");
         // this produces a linefeed!?
         seq->has_parent_reference(true);
         seq->append(SASS_MEMORY_NEW(Parent_Selector, pstate));
diff --git a/node_modules/node-sass/src/libsass/src/parser.hpp b/node_modules/node-sass/src/libsass/src/parser.hpp
index d2a6ddc1..2371dfca 100644
--- a/node_modules/node-sass/src/libsass/src/parser.hpp
+++ b/node_modules/node-sass/src/libsass/src/parser.hpp
@@ -48,23 +48,24 @@ namespace Sass {
     Backtraces traces;
     size_t indentation;
     size_t nestings;
+    bool allow_parent;
 
     Token lexed;
 
-    Parser(Context& ctx, const ParserState& pstate, Backtraces traces)
+    Parser(Context& ctx, const ParserState& pstate, Backtraces traces, bool allow_parent = true)
     : ParserState(pstate), ctx(ctx), block_stack(), stack(0), last_media_block(),
       source(0), position(0), end(0), before_token(pstate), after_token(pstate),
-      pstate(pstate), traces(traces), indentation(0), nestings(0)
+      pstate(pstate), traces(traces), indentation(0), nestings(0), allow_parent(allow_parent)
     { 
       stack.push_back(Scope::Root);
     }
 
     // static Parser from_string(const std::string& src, Context& ctx, ParserState pstate = ParserState("[STRING]"));
-    static Parser from_c_str(const char* src, Context& ctx, Backtraces, ParserState pstate = ParserState("[CSTRING]"), const char* source = 0);
-    static Parser from_c_str(const char* beg, const char* end, Context& ctx, Backtraces, ParserState pstate = ParserState("[CSTRING]"), const char* source = 0);
-    static Parser from_token(Token t, Context& ctx, Backtraces, ParserState pstate = ParserState("[TOKEN]"), const char* source = 0);
+    static Parser from_c_str(const char* src, Context& ctx, Backtraces, ParserState pstate = ParserState("[CSTRING]"), const char* source = nullptr, bool allow_parent = true);
+    static Parser from_c_str(const char* beg, const char* end, Context& ctx, Backtraces, ParserState pstate = ParserState("[CSTRING]"), const char* source = nullptr, bool allow_parent = true);
+    static Parser from_token(Token t, Context& ctx, Backtraces, ParserState pstate = ParserState("[TOKEN]"), const char* source = nullptr);
     // special static parsers to convert strings into certain selectors
-    static Selector_List_Obj parse_selector(const char* src, Context& ctx, Backtraces, ParserState pstate = ParserState("[SELECTOR]"), const char* source = 0);
+    static Selector_List_Obj parse_selector(const char* src, Context& ctx, Backtraces, ParserState pstate = ParserState("[SELECTOR]"), const char* source = nullptr, bool allow_parent = true);
 
 #ifdef __clang__

